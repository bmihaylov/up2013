1.Напишете функция със сигнатура `void pickNumbers(int matrix[][N], int *array);`, която приема матрица N x N (N е глобална константа) и масив с размер N^2 и запазва в него стойностите на всички числа от матрицата. Използвайте тази функция, за да реализирате следната: `int* sortMatrixNumbers(int matrix[][N]);`, която връща масивът, получен чрез 'pickNumbers' сортиран.

2.Напипете функция `int* filterPrimes(int* array, int n);`, която връща масив с простите числа в 'array' (допускат се повторения и наредбата на числата няма значение). Размерът на върнатия масив трябва да бъде точно толкова, колкото е броят на простите (не уникални) числа в 'array'. Не се допуска число от 'array' (не уникално) да бъде проверявано повече от веднъж дали е просто!

3.Напишете фунцкия `void fillSpiral(int matrix[][N]);`, която запълва матрица N x N с числата от 1 до N^2 в спираловиден ред. Например за N = 4 матрицата ще изглежда така:

    1   2   3   4
    12  13  14  5
    11  16  15  6
    10  9   8   7

**(Бонус Задача)** Напишете функция `bool pathExists(char **matrix, int startRow, int startColumn, int endRow, int endColumn)` която проверява дали съществува път от клетка с двойка индекси (startRow, startColumn) до клетка с двойка индекси (endRow, endColumn). Матрицата ще съдържа проходими и непроходими клетки. Проходимите ще бъдат означени с `#`, а непроходимите с `*`. Допуска се движение само вертикално(нагоре и надолу) и хоризонтално(наляво и надясно). Пример: 

Вход:

    ******
    *####*
    *#**#*
    ###*#*
    #*#*#*
    ###*#*
    5 1
    5 4
    
Изход:

    True
