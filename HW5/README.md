1. Реализирайте функцията ` char* dynamicStrCpy(char*& dest, char* source);`,  
	която да копира низът source в низът dest, като ако dest е твърде малък  
    изтрива паметта заделена за dest и заделя нов, достатъчно голям участък   
    от паметта(внимавайте с '\0'). Накрая функцията връща указател към dest,  
    независимо от това дали е заделяна нова памет. Обърнете внимание на това,  
    че dest e псевдоним на указател и си помислете защо е така, ако не се сещате  
    веднага.
2. Реализирайте функцията  
   `char* searchAndReplace(char* text, char* pattern, char* substitute);`  
   searchAndReplace намира всички срещания на низът pattern  в низът text  
   и ги замества със substitute (допуснете, че substitute е винаги със съща-   
   та дължина като pattern, но space е валиден знак). Замяната може да  
   добавя ново срещане  на pattern, така че не прескачайте дължината на   
   pattern.
3. Реализирайте функцията  
	`void words(char* text, char* delimiters)`,  
    която разделя низът text на думи, използвайки като разделители знаците  
    от низа delimiters и ги печата на екрана. Тъй като за един знак(char)  
    е важно само дали е или не е  разделител е хубаво да си изведете  
    проверката в отделна функция:  
    (например `bool isDelimiter(char* x, char* delimiters);`).  
    
    ```  
    Пример:
    text:       ";;A.sentence,zwith_multiplezseparators!z."
    delimiters: ";.z_"
    изход: 
    	   		A
    	   		sentence,
           		with
           		multiple
           		separators!
    ````
4. **(Бонус Задача)**Променете функцията от предишната задача на:  
   `char** words(char* text, char* delimiters)`,
   която трябва вместо да печата разделените думи, да заделя динамична памет
   и да връща масив от низове->съответните думи.  
   **Замислете се защо не е добра  практика да се връща такъв *висящ* указател 
   на програмистът, ползващ вашата функция.**
    
